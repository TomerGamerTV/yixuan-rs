// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum SectionConfigTemplateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SectionConfigTemplate<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SectionConfigTemplate<'a> {
  type Inner = SectionConfigTemplate<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SectionConfigTemplate<'a> {
  pub const VT_SECTION_ID: flatbuffers::VOffsetT = 4;
  pub const VT_SECTION_PHOTO: flatbuffers::VOffsetT = 6;
  pub const VT_NAME: flatbuffers::VOffsetT = 8;
  pub const VT_BORN_TRANSFORM: flatbuffers::VOffsetT = 10;
  pub const VT_ALTERNATIVE_BORN_TRANSFORM: flatbuffers::VOffsetT = 12;
  pub const VT_UNK_3: flatbuffers::VOffsetT = 14;
  pub const VT_SECTION_NAME: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SectionConfigTemplate { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SectionConfigTemplateArgs<'args>
  ) -> flatbuffers::WIPOffset<SectionConfigTemplate<'bldr>> {
    let mut builder = SectionConfigTemplateBuilder::new(_fbb);
    if let Some(x) = args.section_name { builder.add_section_name(x); }
    builder.add_unk_3(args.unk_3);
    if let Some(x) = args.alternative_born_transform { builder.add_alternative_born_transform(x); }
    if let Some(x) = args.born_transform { builder.add_born_transform(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.section_photo { builder.add_section_photo(x); }
    builder.add_section_id(args.section_id);
    builder.finish()
  }


  #[inline]
  pub fn section_id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SectionConfigTemplate::VT_SECTION_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn section_photo(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SectionConfigTemplate::VT_SECTION_PHOTO, None)}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SectionConfigTemplate::VT_NAME, None)}
  }
  #[inline]
  pub fn born_transform(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SectionConfigTemplate::VT_BORN_TRANSFORM, None)}
  }
  #[inline]
  pub fn alternative_born_transform(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SectionConfigTemplate::VT_ALTERNATIVE_BORN_TRANSFORM, None)}
  }
  #[inline]
  pub fn unk_3(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SectionConfigTemplate::VT_UNK_3, Some(0)).unwrap()}
  }
  #[inline]
  pub fn section_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SectionConfigTemplate::VT_SECTION_NAME, None)}
  }
}

impl flatbuffers::Verifiable for SectionConfigTemplate<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("section_id", Self::VT_SECTION_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("section_photo", Self::VT_SECTION_PHOTO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("born_transform", Self::VT_BORN_TRANSFORM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("alternative_born_transform", Self::VT_ALTERNATIVE_BORN_TRANSFORM, false)?
     .visit_field::<i32>("unk_3", Self::VT_UNK_3, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("section_name", Self::VT_SECTION_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct SectionConfigTemplateArgs<'a> {
    pub section_id: u32,
    pub section_photo: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub born_transform: Option<flatbuffers::WIPOffset<&'a str>>,
    pub alternative_born_transform: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unk_3: i32,
    pub section_name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SectionConfigTemplateArgs<'a> {
  #[inline]
  fn default() -> Self {
    SectionConfigTemplateArgs {
      section_id: 0,
      section_photo: None,
      name: None,
      born_transform: None,
      alternative_born_transform: None,
      unk_3: 0,
      section_name: None,
    }
  }
}

pub struct SectionConfigTemplateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SectionConfigTemplateBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_section_id(&mut self, section_id: u32) {
    self.fbb_.push_slot::<u32>(SectionConfigTemplate::VT_SECTION_ID, section_id, 0);
  }
  #[inline]
  pub fn add_section_photo(&mut self, section_photo: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SectionConfigTemplate::VT_SECTION_PHOTO, section_photo);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SectionConfigTemplate::VT_NAME, name);
  }
  #[inline]
  pub fn add_born_transform(&mut self, born_transform: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SectionConfigTemplate::VT_BORN_TRANSFORM, born_transform);
  }
  #[inline]
  pub fn add_alternative_born_transform(&mut self, alternative_born_transform: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SectionConfigTemplate::VT_ALTERNATIVE_BORN_TRANSFORM, alternative_born_transform);
  }
  #[inline]
  pub fn add_unk_3(&mut self, unk_3: i32) {
    self.fbb_.push_slot::<i32>(SectionConfigTemplate::VT_UNK_3, unk_3, 0);
  }
  #[inline]
  pub fn add_section_name(&mut self, section_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SectionConfigTemplate::VT_SECTION_NAME, section_name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SectionConfigTemplateBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SectionConfigTemplateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SectionConfigTemplate<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SectionConfigTemplate<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SectionConfigTemplate");
      ds.field("section_id", &self.section_id());
      ds.field("section_photo", &self.section_photo());
      ds.field("name", &self.name());
      ds.field("born_transform", &self.born_transform());
      ds.field("alternative_born_transform", &self.alternative_born_transform());
      ds.field("unk_3", &self.unk_3());
      ds.field("section_name", &self.section_name());
      ds.finish()
  }
}
pub enum SectionConfigTemplateTbOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SectionConfigTemplateTb<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SectionConfigTemplateTb<'a> {
  type Inner = SectionConfigTemplateTb<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SectionConfigTemplateTb<'a> {
  pub const VT_DATA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SectionConfigTemplateTb { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SectionConfigTemplateTbArgs<'args>
  ) -> flatbuffers::WIPOffset<SectionConfigTemplateTb<'bldr>> {
    let mut builder = SectionConfigTemplateTbBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    builder.finish()
  }


  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SectionConfigTemplate<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SectionConfigTemplate>>>>(SectionConfigTemplateTb::VT_DATA, None)}
  }
}

impl flatbuffers::Verifiable for SectionConfigTemplateTb<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SectionConfigTemplate>>>>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct SectionConfigTemplateTbArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SectionConfigTemplate<'a>>>>>,
}
impl<'a> Default for SectionConfigTemplateTbArgs<'a> {
  #[inline]
  fn default() -> Self {
    SectionConfigTemplateTbArgs {
      data: None,
    }
  }
}

pub struct SectionConfigTemplateTbBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SectionConfigTemplateTbBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<SectionConfigTemplate<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SectionConfigTemplateTb::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SectionConfigTemplateTbBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SectionConfigTemplateTbBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SectionConfigTemplateTb<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SectionConfigTemplateTb<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SectionConfigTemplateTb");
      ds.field("data", &self.data());
      ds.finish()
  }
}
